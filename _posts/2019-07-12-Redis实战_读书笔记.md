---
layout: post
title:  "Redis实战读书笔记"
date:   2019-07-12
categories: Redis
tags: Redis
---

* content
{:toc}




本文为Redis实战的读书笔记

# Redis基础数据结构

Redis中有五种基础数据结构，分别为：string（字符串）、list（列表）、set（集合）、hash（哈希）和zset（有序集合）。

## string(字符串)

字符串string是Redis最简单的数据结构。Redis中所有的数据结构都是以唯一的key字符串作为名称，然后通过这个唯一key值来获取对应的value数据。不同类型的数据结构的差异就在value的结构不一样。value可以是字符串类型、整数或者浮点型。

1. GET	获取存储在给定键中的值

2. SET	设置存储在给定键中的值
3. DEL	删除存储在给定键中的值

Redis 还提供了一些其他操作。比如对数值的自增、自减等。

### list(列表)

list可以有序的存储多个字符串(他们可以是相同的)。

1. RPUSH	将给定值推入列表的右端
2. LRANGE	获取列表在给定范围上的所有值
3. LINDEX	 获取列表在给定位置上的单个元素
4. LPOP		从列表的左端弹出一个值，并且返回被弹出的值

### set（结合）

集合存储多个字符串，其key不相同。通过使用散列列表来保证自己存储的每个字符串都是不一样的。（只针对键的散列）

1. SADD				将给定元素添加到集合中
2. SMEMBERS	  返回集合包含的所有元素
3. SISMEMBER	 检查给定元素是否存在于集合中
4. SREM				如果给定元素存在于集合中，那么移除这个元素		

### 散列（hash）

散列可以存储多个键值对之间的映射。和字符串一样，散列存储的值既可以是字符串又可以是数字值，并且同样可以对散列存储的数字值进行自增操作或者自减操作。

1. HSET 			在散列里面关联起给定的键值对
2. HGET			获取指定散列键的值
3. HGETALL	  获取散列中包含的所有键值对
4. HEDL			如果给定键存在于散列中，那么移除这个键

### 有序集合（zset）

有序集合同样用于存储键值对，有序集合的键被称为成员（member），每个成员都是各不相同的。有序集合的值称之为分值（score 必须为浮点型）。有序集合是Redis中唯一一个既可以根据成员访问元素，又可以根据分值以及分值排序来访问元素的结构。

1. ZADD			将一个带有给定分值的成员添加到有序集合中
2. ZRANGE		根据元素在有序排列中所处位置，从有序集合中获取多个元素
3. ZRANGEBYSCORE	获取有序集合在给定分值范围内的所有元素
4. ZREM			如果给定成员存在于有序集合，那么移除这个成员

## 如何使用这些数据结构呢？

### 对文章进行投票

构建一个文章投票网站，我们首先要做的就是为了这个网站设置一些数值和限制条件：

1. 一篇文章得到了至少200张支持票，那么网站就认为其有趣

2. 网站需要将支持票排名前50篇的文章放到文章列表前显示

3. 需要产生一个随着时间流逝文章评分不断减少的评分。

   具体方法为：文章支持票数*常量 +文章发布时间

   文章投票使用两个有序集合来有序的存储文章：

   1. key-文章ID	value-文章发布时间

   2. key-文章ID	value-文章的评分

      通过这两个集合，网站既可以根据文章发布的先后顺序来展示文章，又可以根据文章评分的高低来展示文章。

      为了防止用户对同一篇文章进行多次投票，同时需要针对每篇文章记录一个已投票用户名单。

      同时，为了节省内存，将对发表了一周以上的文章，用户不能再对其进行投票，文章评分将会被固定下来。

**当用户尝试对一篇文章进行投票的时候，**

1. 程序需要使用ZSCORE命令检查记录文章发布时间，是否超过一周

2. 如果没有超过一周，则需要将用户使用SADD命令添加到投票用户列表中。

3. 如果添加成功，则说明为第一次投票，程序将更新文章对应评分。

   **注意：这三条操作需要放到事务中执行，原子性操作。**

**发布并获取文章**

1. 创建一个新的文章ID，通过计数器（counter）执行INCR命令来完成

2. 将发布者ID添加（SADD）到记录文章已投票用户名单的集合中，并设置过期时间为一周（EXPIRE）。

3. 使用HMSET命令来存储文章的相关信息。

4. 执行两个ZADD命令，初始化两个有序集合（发布时间和评分）

**如何获取评分最高的文章以及如何获取最新发布的文章**

1. 使用ZREVRANGE命令 ，然后针对每个文章ID执行一次HGETALL命令来取出文章详细信息，

**对文章进行分组**

​	群组有两部分组成，一个部分负责记录文章属于哪个群组，另外一个部分负责取出群组中的文章。

​	网站为每个群组创建一个集合，将所有同属于一个群组的文章ID都记录到一个集合中。

## 使用Redis构建Web应用

关于背景：Fake Web Retailer这个网上商店，每天大约有500万不同的用户，给网站带来1亿次点击，并且从网站购买超过10万件商品。

### 登录和cookie缓存

每次我们登录互联网服务的时候，服务都会使用cookie来记录我们的身份。cookie由少量数据组成，网站会要求我们浏览器存储这些数据，同时每次服务发送请求的时候将这些数据传回给服务。对于用来登录的cookie，有两种常见的方法将登录信息存储再cookie中：签名cookie\令牌cookie。

签名cookie通常会存储用户名、用户ID、用户最后一次成功登录的时间以及王章觉得有用的其他信息。服务器会使用签名来验证该信息是否被改动过。

令牌cookie会再cookie中存储一串随机字节作为令牌，服务器可以根据令牌再数据库中查找令牌的拥有者。

<img src="https://xuzuguang.men//images/posts/cookie.png" alt="图-抄的呢" style="zoom:50%;" />

FWR采取令牌cookie。除去登录信息外，FWR还可以将用户的访问时长、浏览记录等存储到数据库中，这样便于将来对用户行为进行分析。

用户在决定购买某些商品前，通常会先浏览多个不同的商品，而记录用户浏览过的所有商品以及用户最后一次访问页面的时间等信息，会导致相关的数据库写操作。针对FWR当前的负载，大体每秒1200次写入，高峰6000次写入。

**使用Redis来实现登录cookie功能**

1. 使用一个散列来存储登录cookie令牌与登录用户之间映射。要检查一个用户是否已经登录，需要根据给定令牌来查找对应的用户。再用户登录情况下，返回该用户ID。
2. 用户每次浏览页面的时候，会对用户存储再散列中的信息进行更新，并将用户的令牌和当前时间戳天机道到记录最近用户登录的有序结合中。

3. 如果用户正在浏览一个商品，则会将该商品添加到记录用户最近浏览过的商品的有序集合中，并且再记录商品的数量超过25个时候，对有序集合进行修剪
4. 由于存储会话数量所需内存会随着时间的推移不断增加，所以我们需要定期清理旧的会话数据。比如只保存最新的1000万个会话。清理会话程序由一个循环构成，这个循环每次执行时候，都会检查存储最近登录令牌的有序集合的大小。
5. 如果超出限制，程序就会从有序集合中移除最多100个最旧的令牌，并从记录用户登录信息的散列中，移除被删除令牌对应的用户信息，并对这些用户浏览商品记录的有序集合进行清理。
6. 如果没有超出限制，则会休眠一段时间，然后重新检查。

### 使用Redis实现购物车

使用cookie实现购物车—也就是将购物车都存储到cookie里的做法非常常见，

​	优点：无须对数据库进行写入就可以实现购物车功能，

​	缺点：是程序需要重新解析和验证cookie，确保cookie的格式正确，并且确保所包含的商品是真正可购买的商品。浏览器每次发送请求的时候都会连cookie一起发送，所以如果购物车的cookie体积过大，那么请求发送和处理的速度可能会有所降低。

**那么如何使用Redis来实现会话cookie和记录用户最近浏览过的商品这两个特性呢？**

所以我们决定将购物车信息也存储到Redis中，并且使用与会话cookie相同的cookieID来引用购物车。

购物车的定义非常简单：每个用户的购物车都是一个散列，这个散列存储了商品ID和商品订购数量之间的映射。我们需要做的是再商品订购数量出现变化的时候，对购物车进行更新。

​	1：如果订购数量大于0，程序会将商品ID以及订购数量添加到散列中，

​	2：如果商品ID已经存在，则更新数量。

​	3：如果数量为0，程序将从散列中移除该条目。

​	4：那么之前的清理会话函数需要稍微修改，再清理旧的会话的同时，将旧的会话对应的用户购物车也一并删除。

### 网页缓存

在动态生成网页的时候，通常会使用模板语言来简化网页的生成操作。

尽管FWR也能够动态的生成内容，但是这个网站上多数页面实际上并不会经常发生大的变化。一般情况下，网站中只有账号设置、以往订单、购物车以及其他的少数页面才包含需要每次载入都要动态生成的内容。

因此，我们可以想办法不再生成这些页面，减少网站在动态生成内容上面所花费的时间，可以减少网站处理相同负载所需要的服务器数量，让网站速度更快。

#### 数据行缓存

FWR的商品页面通常只会从数据库中载入一两行数据，包括用户信息以及商品本身信息，程序可以通过缓存页面载入时候所需要的数据库行来减少页面所需时间。

但是，在促销或者秒杀的时候，网站是不能对促销或者秒杀商品页面进行缓存的，因为这样可能会导致用户看到错误的特价商品的价格错误或者剩余数量不对。但是每次载入页面都从数据库中取出特价商品的剩余数量，又会给数据库带来巨大的压力。

为了应对促销活动带来的大量负载，我们需要对数据进行缓存。具体做法：

1. 编写一个持续运行的守护进程函数，让这个函数将指定的数据行缓存到Redis中，并不定期对这些缓存进行更新。缓存函数会将数据行编码为JSON并存储到Redis中。

2. 程序使用两个有序集合来记录应该在何时对缓存进行更新：

   第一个集合为调度有序集合，成员为数据行的ID，分值则为时间戳。时间戳记录应该在何时将指定的数据行缓存到Redis里面

   第二个有序集合为延时有序集合，它的成员为数据行的ID，分值为数据行缓存需要多久更新一次。

3. 为了让缓存函数定期的缓存数据行，程序手续需要将行ID和给定的延迟值添加到延迟有序集合里，然后再将行ID和当前时间的时间戳添加到调度有序集合里面。实际执行缓存操作的函数需要用到数据行的延迟值，如果延迟值不存在，则取消对数据行的调度。如果想移除某个数据的缓存，并且让缓存函数不再缓存那个数据行，那么只需要将数据行的延迟值设置为小于或者等于0即可。