---

layout: 	post
title:  	"常用的排序算法总结"
date:   	2016-08-04 20:14:54
categories: 	算法
tags: 	算法  sort
excerpt: 	常见的排序算法总结
mathjax: 	true

---

* content

  {:toc}

# 排序算法

| 排序算法 | 时间复杂度 | 最好情况 | 最坏情况 | 空间复杂度 | 排序方式 | 稳定 |
| :------: | :--------: | :------: | :------: | :--------: | :------: | :--: |
| 冒泡排序 |   O(n^2)   |   O(n)   |  O(n^2)  |    O(1)    |          | YES  |
|          |            |          |          |            |          |      |
|          |            |          |          |            |          |      |
|          |            |          |          |            |          |      |

> 注：
>
> ​		表中时间复杂度为平均时间复杂度
>
> ​		稳定性：相同数字是否保持原顺序
>
> ​		排序方式：是否需要额外的空间
>
> ​		排序为生序（除了堆外）



## 冒泡排序

> 思路：遍历数组n次（n为数的个数），比较两个数的大小，较大的数下沉，较少的数上浮。

 ````c++
void bubble_Sort(vector<int>& arr){
    int size = arr.size();
    // 第i轮
    for(int i = 0 ; i < size - 1 ; i++){ 
    // 从最后一个数字开始依次向前比较，由于每次将最小的数浮到最上面。
    // 因此，每轮过后 需要比较的次数将减少一次
        for(int j = size - 1 ; j > i ; j--){ 
            if(arr[j] < arr[j-1]){
                swap(arr[j] , arr[j-1]);
            }
        }
	}
}
 ````

> 优化思路：数据数据顺序排好之后，冒泡排序依然会进行下一轮比较，而后面的遍历都是多余的。
>
> 因此，可以设置标志位，当某一轮没有发生交换的时候，则结束排序。
>
> eg： 针对 1234576 ，当进行完第一轮比较后，数组已经排序完成，在第二轮比较中，不会发生任何的交换。可以在第二轮之后便结束排序。

````c++
void bubble_SortOP(vector<int>& arr){
    int size = arr.size();
    bool flag = false;
    for(int i = 0 ; i < size -1 ; i++){
        flag = false;//每次遍历前设置为false
        for(int j = size -1 ; j > i ; j--){
            if(arr[j] < arr[j-1]){
                swap(arr[j] , arr[j-1]);
                flag = true;// 如果发生一次交换，则设置为true
            }
            if(!flag)// 如果当前轮比较未发生交换，则数据已经排序完成，推出循环。
                break;
        }
    }
}
````

## 选择排序

> 思路：每次选择数组中剩余数最小的，将其放到最前面（与对应位置进行交换）。

````c++
void selection_sort(vector<int>& arr) {
    int size = arr.size();
    for (int i = 0; i < size - 1; i++) {
        int minIdx = i;
        for (int j = size - 1; j > i; j--) {
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }
        swap(arr[i], arr[minIdx]);
    }
}
````

## 插入排序

> 思路：遍历数组，第K个数分别与前K-1个数进行比较，并且找到自己的位置。

````c++
void insertion_Sort(vecotr<int>& arr){
    int size = arr.size();
    for(int i = 1 ; i < size ; i++){
        for(int j = i ; j > 0 ; j--){
            if(arr[j] < arr[j-1]){
                swap(arr[j] , arr[j-1]);
            }else{
                break;
            }
        }
    }
}
````

## 归并排序

> 思想：采用分治法 ，将数组分成两组 A和B，如果A 、B组内有序，那么归并这两个子序列就能够得到有序序列。如下图所示：

<img src="../images/posts/merge.gif">

````c++
void merge_Sort(vector<int>& arr , int begin , int end){
    if(begin < end){
        int mid = (begin + end)/2;
        merge_Sort(arr , begin , mid);// 排序左半部分
        merge_Sort(arr , mid + 1 , end);// 排序右半部分
        merge(arr , begin , mid , end);// 合并左右部分
    }
}

void merge(vector<int>& arr , int begin , int mid , int end){
    
}
````









