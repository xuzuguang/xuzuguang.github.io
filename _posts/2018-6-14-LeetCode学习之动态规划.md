---
layout: post
title:  "LeetCode学习之动态规划"
date:   2018-06-14
categories: 算法学习  
tags: 算法学习

---

* content
{:toc}


本文为LeetCode中关于动态规划的题目学习

#  动态规划详解

动态规划（英语：Dynamic programming，简称 DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。

动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。

动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。动态规划往往用于优化递归问题，例如斐波那契数列，如果运用递归的方式来求解会重复计算很多相同的子问题，利用动态规划的思想可以减少计算量。

通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，具有天然剪枝的功能，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。

动态规划问题的⼀般形式就是求最值。动态规划其实是运筹学的⼀种最优化⽅法，只不过在计算机问题上应⽤⽐较多，⽐如说让你求最⻓递增⼦序列呀，最⼩编辑距离呀等等。既然是要求最值，核⼼问题是什么呢？求解动态规划的核⼼问题是穷举。因为要求最值，肯定要把所有可⾏的答案穷举出来，然后在其中找最值呗。动态规划就这么简单，就是穷举就完事了？我看到的动态规划问题都很难
啊！

⾸先，动态规划的穷举有点特别，因为这类问题存在「重叠⼦问题」，如果暴⼒穷举的话效率会极其低下，所以需要「备忘录」或「DP	table」来优化穷举过程，避免不必要的计算。

⽽且，动态规划问题⼀定会具备「最优⼦结构」，才能通过⼦问题的最值得到原问题的最值。

另外，虽然动态规划的核⼼思想就是穷举求最值，但是问题可以千变万化，穷举所有可⾏解其实并不是⼀件容易的事，只有列出正确的「状态转移⽅程」才能正确地穷举。
以上提到的**重叠⼦问题、最优⼦结构、状态转移⽅程**就是动态规划三要素。具体什么意思等会会举例详解，但是在实际的算法问题中，写出状态转移⽅程是最困难的，这也就是为什么很多朋友觉得动态规划问题困难的原因，现在来提供思维框架，辅助我们思考状态转移⽅程：
	**明确「状态」**	->	**定义	dp	数组/函数的含义**	->	**明确「选择」**->	**明确	base case**。

## LeetCode题目集合

#### [剑指 Offer 42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

难度简单63收藏分享切换为英文关注反馈

输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。

**示例1:**

```
输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

**提示：**

- `1 <= arr.length <= 10^5`
- `-100 <= arr[i] <= 100`

**代码:**

```c++
int maxSubArray(vector<int>& nums) {
    /**
        dp[n] = dp[n-1] + nums[n]   (dp[n-1] + nums[n] >= nums[n])
              = nums[n]             (dp[n-1] + nums[n] < nums[n])
        dp[0] = nums[0]     
    **/
    if(nums.size() == 0) return 0 ;
    int res = nums[0] , dpN = nums[0];
    for(int i = 1 ; i < nums.size() ; i++){
        dpN = dpN + nums[i] >= nums[i] ? dpN + nums[i] : nums[i];
        res = max(dpN , res);
    }
    return res;
}
```

 [303. 区域和检索 - 数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/)

难度简单163收藏分享切换为英文关注反馈

给定一个整数数组  *nums*，求出数组从索引 *i* 到 *j* (*i* ≤ *j*) 范围内元素的总和，包含 *i, j* 两点。

**示例：**

```
给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()

sumRange(0, 2) -> 1
sumRange(2, 5) -> -1
sumRange(0, 5) -> -3
```

**说明:**

1. 你可以假设数组不可变。
2. 会多次调用 *sumRange* 方法。

**代码：**

```c++
vector<int> vecSum;
NumArray(vector<int>& nums) {
    vecSum.resize(nums.size() + 1);
    vecSum[0] = 0;
    for(int i = 0 ; i < nums.size() ; i++)
        vecSum[i+1] = vecSum[i] + nums[i];
}

int sumRange(int i, int j) {
    return vecSum[j+1] - vecSum[i]; 
}
```

